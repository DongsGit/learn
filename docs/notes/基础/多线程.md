### 实现多线程的几种方式
* 继承Thread类
* 实现Runnable接口
* 实现Callable接口通过Future包装器来创建Thread线程
* 通过线程池创建  

### 线程的生命周期（或状态）
创建 ➔ 就绪 ➔ 运行 ➔ 阻塞 ➔ 终止

### 并发的三大特性（线程安全必须满足）
* 原子性
* 可见性
* 有序性

### start()和run()方法的区别
* 直接调用run()则相当于普通调用
* 调用start()后线程会被放到等待队列，然后通过JVM线程thread会调用run();

### 乐观锁和悲观锁的区别
* 乐观锁：每次去拿数据的时候认为其他线程不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别的线程有没有去跟新这个数据（数据库增加version字段来实现乐观锁）
* 悲观锁：共享资源每次只给一个线程使用，其他线程阻塞，用完后再把资源让给其他线程；Java中的Synchronized就是悲观锁

### sleep()和wait()方法的区别
* 相同：sleep()和wait()都会暂停当前线程并让出CPU
* 不同：
  * 定义位置：sleep()是线程类Thread的方法，wait()是顶级类Object的方法
  * 调用地方：sleep()可以在任何地方使用，wait()方法只能在`同步方法`和`同步块`中使用
  * 锁资源释放方式：sleep()不会释放锁，wait()会释放锁
  * 恢复方式不同：sleep()调用后停止运行期间仍持有同步锁，所以到时间会继续支持；wait()调用会放弃对象锁，进入等待队列，待调用notify()、notifyAll()唤醒指定的线程或所有线程

### ThreadLocal的使用场景
ThreadLocal作用在每个线程内都需要独立的保存信息，这样就方便同一个线程的其他方法获取到该信息的场景，由于每一个线程获取到的信息可能都是不一样的，前面执行的方法保存了信息之后，后续的方法可以通过ThreadLocal可以获取到，避免了传参，类似于全局变量的概念

### 多线程死锁
死锁是指多线程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些线程都将无法向前推进，解决方案：
* 线程之间交错执行，解决：以固定顺序枷锁
* 永久等待，解决：使用tryLock()定时锁，超过时限则返回错误信息

### ThreadPoolExecutor线程池7大参数:star:
* coolPoolSize：核心线程数
* maximumPoolSize：允许最大的线程数
* keepAliveTime：控线线程保留的时间
* unit：线程保留时间的单位
* BlockingQueue workQueue：阻塞队列（任务缓冲区）
* threadFactory：线程的构造工厂，主要用来创建线程
* handler：线程池饱和时候的处理策略

### Executors工厂类提供的线程池有哪些
* newCachedTheThreadPool：`maximumPoolSize`为Integer.MAX_VALUE，适用：执行很多短期异步的小程序或者负载较轻的服务器
* newFixedThreadPool：允许的请求队列长度为Integer.MAX_VALUE，适用：执行长期的任务，性能好很多
* newSingleThreadPool：允许的请求队列长度为Integer.MAX_VALUE，适用：一个任务一个任务执行的场景
* newScheduledThreadPool：`maximumPoolSize`为Integer.MAX_VALUE,适用：周期性执行任务的场景

### 什么是轻量级锁和重量级锁
* 轻量级锁：无实际竞争，多个线程交替使用锁，允许短时间的锁竞争
* 重量级锁：有实际竞争，且锁竞争时间长

### Synchronized和Lock的区别:star:
| 锁类型 | 性能 | 锁机制 | 编程 | 用法 |
| --- | --- | --- | --- | --- |
| Synchronized | 竞争不激烈的情况下，Synchronize比Lock性能好 | 在JVM层面实现的，系统会监控锁的释放与否 | 编程更简洁 | * 同步代码块；同步方法（包含静态方法）；修饰一个类synchronized(MyClass.class) |
| Lock         | 资源竞争激烈的情况下，Lock性能好 | JDK代码实现的，需要手动释放，在finally块中释放 | 功能更多更灵活，但是一定要在finally里面unlock()解锁才行 | 只能写在代码里，不能直接修改方法 |

### 常见的锁有哪些
* Synchronized关键字：Java中最基本的锁机制，可以用来修饰方法或代码块
* ReentranLock：Lock锁的实现类，具有可重入性，允许一个线程多次获取同一个锁，而不会死锁
* Read/Write Locks（读写锁）：ReentrantReadWriteLock 是 Lock 的另一个实现，它允许多个线程同时读取共享资源，但只允许一个线程写入；
