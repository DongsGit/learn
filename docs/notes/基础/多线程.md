### 实现多线程的几种方式
* 继承Thread类
* 实现Runnable接口
* 实现Callable接口通过Future包装器来创建Thread线程
* 通过线程池创建  

### 线程的生命周期（或状态）
创建 ➔ 就绪 ➔ 运行 ➔ 阻塞 ➔ 终止

### 并发的三大特性（线程安全必须满足）
* 原子性
* 可见性
* 有序性

### start()和run()方法的区别
* 直接调用run()则相当于普通调用
* 调用start()后线程会被放到等待队列，然后通过JVM线程thread会调用run();

### 乐观锁和悲观锁的区别
* 乐观锁：每次去拿数据的时候认为其他线程不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别的线程有没有去跟新这个数据（数据库增加version字段来实现乐观锁）
* 悲观锁：共享资源每次只给一个线程使用，其他线程阻塞，用完后再把资源让给其他线程；Java中的Synchronized就是悲观锁

### sleep()和wait()方法的区别
* 相同：sleep()和wait()都会暂停当前线程并让出CPU
* 不同：
  * 定义位置：sleep()是线程类Thread的方法，wait()是顶级类Object的方法
  * 调用地方：sleep()可以在任何地方使用，wait()方法只能在`同步方法`和`同步块`中使用
  * 锁资源释放方式：sleep()不会释放锁，wait()会释放锁
  * 恢复方式不同：sleep()调用后停止运行期间仍持有同步锁，所以到时间会继续支持；wait()调用会放弃对象锁，进入等待队列，待调用notify()、notifyAll()唤醒指定的线程或所有线程

### ThreadLocal的使用场景[参考](https://segmentfault.com/a/1190000041264583)
ThreadLocal作用在每个线程内都需要独立的保存信息，这样就方便同一个线程的其他方法获取到该信息的场景，由于每一个线程获取到的信息可能都是不一样的，前面执行的方法保存了信息之后，后续的方法可以通过ThreadLocal可以获取到，避免了传参，类似于全局变量的概念

### 多线程死锁
死锁是指多线程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些线程都将无法向前推进，解决方案：
* 线程之间交错执行，解决：以固定顺序枷锁
* 永久等待，解决：使用tryLock()定时锁，超过时限则返回错误信息

### x