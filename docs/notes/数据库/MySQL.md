### 索引失效常见情况
* 索引列参与了运算
* 索引列使用了函数
* 隐式类型转换
* 两列作比较
* is null、is not null等
* or有可能也会导致索引失效
* 不等于、不小于、不大于、not in、not exist、between等范围查询
* 错误的like的使用，最左边不能出现占位
* 联合索引不满足最左匹配原则（指的是联合索引中，优先走最左边列的索引）

### 表锁和行锁的区别
* 表锁：开销小，加锁快，不会出现死锁；锁的粒度大，发生锁冲突概率高，并发度最低。
* 行锁：开销大，加锁慢，会出现死锁；锁粒度小，发生锁冲突概率低，并发度高；行锁必须有索引才能实现，否则会自动锁全表。

### limit 分页前几页很快，后续效率会变低，这是为什么？
前几页只需要扫描较少的索引页，但是随着页面的增加，需要扫描的索引页数量会增加，从而导致查询速度变慢。
优化方案：
```sql
select *from ad_keyword a JOIN (select id from ad_keyword  LIMIT 10000000,1000) b on a.id=b.id ;
```

### MySQL存储引擎对比
* MySAM：成熟、稳定、易于管理、快速读取；不支持表级锁、事物等。
* InnoDB：空间占用大；支持事务、外键、数据行锁定等特性、有缓冲池；不支持全文索引。

### 索引种类有哪些及类别
* 普通索引：仅加速查询
* 唯一索引：加速查询+列值唯一（可以有null）
* 主键索引：加速查询+列值唯一（不可以有null）
* 组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并
* 全文索引：对文本的内容进行分词，进行搜索

### 索引的数据结构，Hash索引与B+树索引的区别
* Hash索引不能进行范围查询，而B+树可以；
* Hash索引不支持联合索引的最左原则（即联合索引的部分索引无法使用），而B+树可以；
* Hash索引不支持Order By排序，而B+树支持；
* Hash索引无法进行模糊查询，而B+树使用like进行模糊查询的时候，like后面左模糊查询可以起到优化的作用；
* Hash索引在等值查询上比B+树效率更高；

### B树索引和B+树索引的区别
B树索引每个节点包含键值和对应的数据，B+树中，所有数据存储在叶子节点，非叶子节点只包含键值和指向下层节点的指针。

### explain的结果type速度排行
system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL

### SQL查询慢优化步骤
1. 通过日志查询出来执行慢的SQL
2. explain执行计划查看SQL是否走索引
3. 判断字段查询是否适合走索引，是否是索引失效

### 如何判断该索引是否适合建
通过`show index from 表名`查询所有索引，结果里面有个关键字叫Cardinality，这个值除以数据的总行数的值越接近1就代表越适合建索引，否则如果数值过小则需要考虑是否有建索引的必要。

### 什么是聚簇索引和非聚簇索引
* 聚簇索引：将数据存储和索引放到了一块，找了了索引也就找到了数据；表数据按照索引顺序来存储的，也就是说索引项的顺序与表中记录的物理顺序一致。、
* 非聚簇索引：将数据存储与索引分开，叶节点包含索引字段值及指向数据页数据行的逻辑指针，其行数量与数据表行数量一致。

### 回表的概念
使用非聚簇索引进行查询是，如果查询到非索引字段则需要通过指向数据行的逻辑指针再去查一遍。

### MySQL的执行流程